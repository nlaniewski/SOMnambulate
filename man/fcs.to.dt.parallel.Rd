% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fcs_funcs.R
\name{fcs.to.dt.parallel}
\alias{fcs.to.dt.parallel}
\title{a parallelized version of \link{fcs.to.dt}}
\usage{
fcs.to.dt.parallel(
  fcs.file.dt,
  channel_alias = NULL,
  use.alias.pattern = FALSE,
  alias.order = FALSE,
  cofactors = NULL,
  sample.val = NULL,
  seed.val = 1337,
  ncores = NULL,
  ...
)
}
\arguments{
\item{fcs.file.dt}{a \code{data.table} as returned from \link{get.fcs.file.dt}; \code{fcs.file.dt} can be subset to include only columns-of-interest (a minimally-representative subset would include only 'f.path' and 'sample.id').}

\item{channel_alias}{as returned from \link{get.fcs.channel.alias}}

\item{use.alias.pattern}{Logical; default \code{FALSE}. If \code{TRUE} and \code{channel_alias} is defined, the 'alias' column will be used as a pattern to define the \link[flowCore]{read.FCS} \code{column.pattern} argument.}

\item{alias.order}{Logical. If \code{TRUE}, the \code{data.table} columns will be ordered to match that of the \code{channel_alias} 'alias' column.}

\item{cofactors}{A named numeric vector; named columns will be \link[base]{asinh} transformed with the supplied cofactor (numeric).}

\item{sample.val}{Numeric (1L); used to define \link[base:sample]{size}. Rows will be randomly (seed-controlled) selected based on the value of \code{sample.val}.}

\item{seed.val}{A (default elite) random seed value used to control row-sampling.}

\item{ncores}{Numeric; used to override the number of parallel compute clusters.}

\item{...}{Further arguments passed to \link[data.table]{rbindlist}; primarily used to define \code{fill=TRUE} when the data.tables are not harmonized.}
}
\value{
a \code{data.table} of raw, un-transformed numeric expression values (row-bound) with character/factor identifier columns; if \code{cofactors} is defined, the raw expression values will be \link[base]{asinh} transformed.
}
\description{
Essentially a wrapper around \link[parallel]{makeCluster} and those associated functions.  There is 'computational' overhead in initiating the compute clusters but for many .fcs files, this parallelized version of \link{fcs.to.dt} should speed up the workflow.  There is risk of saturating all available RAM if the data set is large enough;  it is recommended to monitor system resources (Task Manager/Activity Monitor).
}
\examples{
#because of the small file-size of these example .fcs files,
#it's faster to read them individually with 'fcs.to.dt';
#for larger/many files, the overhead of initiating the compute clusters is negligible
#compared to the speed savings of parallel reading

#from the 'get.fcs.file.dt' example:
fcs.files.dt<-SOMnambulate:::prepared.examples('fcs.files.dt')

#from the 'get.fcs.channel.alias' example:
ca<-SOMnambulate:::prepared.examples('channel.alias')

dt<-fcs.to.dt.parallel(
fcs.file.dt=fcs.files.dt[,.(f.path,sample.id,batch,stim.condition,aliquot.seq)],
channel_alias=ca,use.alias.pattern=TRUE,alias.order=TRUE,sample.val=1000,ncores=2)
dt[]
dt[,.N,by=sample.id]

}
